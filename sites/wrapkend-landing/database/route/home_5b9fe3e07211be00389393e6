const isProd = process.env.NODE_ENV === 'production'
  
module.exports = app => {
	var _ = app.require('lodash');
 
	function pug(filePath, vars = {}) {
		var p = require('path').join(process.cwd(), 'tmp/pugs', filePath.split('.pug').join(''))
		return app.require('pug').compileFile(p)(vars)
	}

	app.get('/', safeRoute(async (req, res) => {
		res.send(pug('home'));
	}));
	app.get('/privacy-terms', safeRoute(async (req, res) => {
		res.send(pug('privacy'));
	}));

	function safeRoute(handler) {
		return async (req, res) => {
			try {
				await handler(req, res)
			} catch (err) {
				console.error('ERROR [app route]', err.stack);
			}
		}
	}
};

function vue(app) {
	const templatePath = require('path').join(process.cwd(), 'tmp/pugs/index.template.html')
	const {
		createBundleRenderer
	} = app.require('vue-server-renderer')


	var setupDevServer = devServer(app);
	var readyPromise = setupDevServer(
		app,
		templatePath,
		(bundle, options) => {
			renderer = createRenderer(bundle, options)
		}
	)

	app.get('*', isProd ? render : (req, res) => {
		readyPromise.then(() => render(req, res))
	})

	function createRenderer(bundle, options) {
		return createBundleRenderer(bundle, Object.assign(options, {
			cache: LRU({
				max: 1000,
				maxAge: 1000 * 60 * 15
			}),
			basedir: resolve('./dist'),
			runInNewContext: false
		}))
	}
}

function devServer(app) {
	const fs = app.require('fs')
	const path = app.require('path')
	const MFS = app.require('memory-fs')
	const webpack = app.require('webpack')
	const chokidar = app.require('chokidar')
	const clientConfig = webpackClientConfig(app)
	const serverConfig = webpackServerConfig(app)

	const readFile = (fs, file) => {
		try {
			return fs.readFileSync(path.join(clientConfig.output.path, file), 'utf-8')
		} catch (e) {}
	}

	return function setupDevServer(app, templatePath, cb) {
		let bundle
		let template
		let clientManifest

		let ready
		const readyPromise = new Promise(r => {
			ready = r
		})
		const update = () => {
			if (bundle && clientManifest) {
				ready()
				cb(bundle, {
					template,
					clientManifest
				})
			}
		}

		// read template from disk and watch
		template = fs.readFileSync(templatePath, 'utf-8')
		chokidar.watch(templatePath).on('change', () => {
			template = fs.readFileSync(templatePath, 'utf-8')
			console.log('index.html template updated.')
			update()
		})

		// modify client config to work with hot middleware
		clientConfig.entry.app = ['webpack-hot-middleware/client', clientConfig.entry.app]
		clientConfig.output.filename = '[name].js'
		clientConfig.plugins.push(
			new webpack.HotModuleReplacementPlugin(),
			new webpack.NoEmitOnErrorsPlugin()
		)

		// dev middleware
		const clientCompiler = webpack(clientConfig)
		const devMiddleware = require('webpack-dev-middleware')(clientCompiler, {
			publicPath: clientConfig.output.publicPath,
			noInfo: true
		})
		app.use(devMiddleware)

		clientCompiler.plugin('done', stats => {
			stats = stats.toJson()
			stats.errors.forEach(err => console.error(err))
			stats.warnings.forEach(err => console.warn(err))
			if (stats.errors.length) return
			clientManifest = JSON.parse(readFile(
				devMiddleware.fileSystem,
				'vue-ssr-client-manifest.json'
			))
			update()
		})

		// hot middleware
		app.use(require('webpack-hot-middleware')(clientCompiler, {
			heartbeat: 5000
		}))

		// watch and update server renderer
		const serverCompiler = webpack(serverConfig)
		const mfs = new MFS()
		serverCompiler.outputFileSystem = mfs
		serverCompiler.watch({}, (err, stats) => {
			if (err) throw err
			stats = stats.toJson()
			if (stats.errors.length) return

			// read bundle generated by vue-ssr-webpack-plugin
			bundle = JSON.parse(readFile(mfs, 'vue-ssr-server-bundle.json'))
			update()
		})

		return readyPromise
	}
}

function webpackClientConfig(app) {
	const webpack = app.require('webpack')
	const merge = app.require('webpack-merge')
	const base = webpackBaseConfig(app)
	const SWPrecachePlugin = app.require('sw-precache-webpack-plugin')
	const VueSSRClientPlugin = app.require('vue-server-renderer/client-plugin')

	const config = merge(base, {
		entry: {
			app: './src/entry-client.js'
		},
		resolve: {
			alias: {
				'create-api': './create-api-client.js'
			}
		},
		plugins: [
			// strip dev-only code in Vue source
			new webpack.DefinePlugin({
				'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development'),
				'process.env.VUE_ENV': '"client"'
			}),
			// extract vendor chunks for better caching
			new webpack.optimize.CommonsChunkPlugin({
				name: 'vendor',
				minChunks: function(module) {
					// a module is extracted into the vendor chunk if...
					return (
						// it's inside node_modules
						/node_modules/.test(module.context) &&
						// and not a CSS file (due to extract-text-webpack-plugin limitation)
						!/\.css$/.test(module.request)
					)
				}
			}),
			// extract webpack runtime & manifest to avoid vendor chunk hash changing
			// on every build.
			new webpack.optimize.CommonsChunkPlugin({
				name: 'manifest'
			}),
			new VueSSRClientPlugin()
		]
	})

	if (process.env.NODE_ENV === 'production') {
		config.plugins.push(
			// auto generate service worker
			new SWPrecachePlugin({
				cacheId: 'vue-hn',
				filename: 'service-worker.js',
				minify: true,
				dontCacheBustUrlsMatching: /./,
				staticFileGlobsIgnorePatterns: [/\.map$/, /\.json$/],
				runtimeCaching: [{
						urlPattern: '/',
						handler: 'networkFirst'
					},
					{
						urlPattern: /\/(top|new|show|ask|jobs)/,
						handler: 'networkFirst'
					},
					{
						urlPattern: '/item/:id',
						handler: 'networkFirst'
					},
					{
						urlPattern: '/user/:id',
						handler: 'networkFirst'
					}
				]
			})
		)
	}
	return config;

}


function webpackBaseConfig(app) {
	const path = require('path')
	const webpack = app.require('webpack')
	const ExtractTextPlugin = app.require('extract-text-webpack-plugin')
	const FriendlyErrorsPlugin = app.require('friendly-errors-webpack-plugin')
	const {
		VueLoaderPlugin
	} = require('vue-loader')

	const isProd = process.env.NODE_ENV === 'production'

	return {
		devtool: isProd ?
			false : '#cheap-module-source-map',
		output: {
			path: path.resolve(__dirname, '../dist'),
			publicPath: '/dist/',
			filename: '[name].[chunkhash].js'
		},
		resolve: {
			alias: {
				'public': path.resolve(__dirname, '../public')
			}
		},
		module: {
			noParse: /es6-promise\.js$/, // avoid webpack shimming process
			rules: [{
					test: /\.vue$/,
					loader: 'vue-loader',
					options: {
						compilerOptions: {
							preserveWhitespace: false
						}
					}
				},
				{
					test: /\.js$/,
					loader: 'babel-loader',
					exclude: /node_modules/
				},
				{
					test: /\.(png|jpg|gif|svg)$/,
					loader: 'url-loader',
					options: {
						limit: 10000,
						name: '[name].[ext]?[hash]'
					}
				},
				{
					test: /\.styl(us)?$/,
					use: isProd ?
						ExtractTextPlugin.extract({
							use: [{
									loader: 'css-loader',
									options: {
										minimize: true
									}
								},
								'stylus-loader'
							],
							fallback: 'vue-style-loader'
						}) : ['vue-style-loader', 'css-loader', 'stylus-loader']
				},
			]
		},
		performance: {
			maxEntrypointSize: 300000,
			hints: isProd ? 'warning' : false
		},
		plugins: isProd ? [
			new VueLoaderPlugin(),
			new webpack.optimize.UglifyJsPlugin({
				compress: {
					warnings: false
				}
			}),
			new webpack.optimize.ModuleConcatenationPlugin(),
			new ExtractTextPlugin({
				filename: 'common.[chunkhash].css'
			})
		] : [
			new VueLoaderPlugin(),
			new FriendlyErrorsPlugin()
		]
	}
}

function webpackServerConfig(app) {
	const webpack = app.require('webpack')
	const merge = app.require('webpack-merge')
	const base = webpackBaseConfig(app)
	const nodeExternals = app.require('webpack-node-externals')
	const VueSSRServerPlugin = app.require('vue-server-renderer/server-plugin')
	const entry = require('path').join(process.cwd(),'tmp/pugs/entry-server.js')
	const createApiPath = require('path').join(process.cwd(),'tmp/pugs/create-api-server.js')
	return merge(base, {
		target: 'node',
		devtool: '#source-map',
		entry: entry,
		output: {
			filename: 'server-bundle.js',
			libraryTarget: 'commonjs2'
		},
		resolve: {
			alias: {
				'create-api': createApiPath
			}
		},
		// https://webpack.js.org/configuration/externals/#externals
		// https://github.com/liady/webpack-node-externals
		externals: nodeExternals({
			// do not externalize CSS files in case we need to import it from a dep
			whitelist: /\.css$/
		}),
		plugins: [
			new webpack.DefinePlugin({
				'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development'),
				'process.env.VUE_ENV': '"server"'
			}),
			new VueSSRServerPlugin()
		]
	})
}